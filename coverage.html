
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">./rislive.go (25.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package rislive implements a service to listen to the RIPE RIS Live service,
// Messages from RIS Live are parsed and sent to a channel for use be clients.
// There are filter capabilities for clients:
//  ASPaths - monitor for prefixes matching an as-path fragment (slice)
//  InvalidTransitAS - monitor for prefixes transiting an AS that shouldn't transit that AS. (map)
//  Origins - monitor for prefixes with designated origins (slice)
//  Prefix - monitor for a designated set of prefixes (slice)
//
package main

import (
        "bytes"
        "encoding/json"
        "flag"
        "fmt"
        "io"
        "io/ioutil"
        "net"
        "net/http"
        "os"
        "reflect"

        log "github.com/golang/glog"
)

var (
        risFile   = flag.String("risFile", "", "A file of json content, to help in testing.")
        risLive   = flag.String("rislive", "https://ris-live.ripe.net/v1/stream/?format=json", "RIS Live firehose url")
        risClient = flag.String("risclient", "golang-rislive-morrowc", "Clientname to send to rislive")
        buffer    = flag.Int("buffer", 1000, "Max depth of Ris messages to queue.")
)

// RisLive is a struct to hold basic data used in connecting to the RIS Live service
// and managing data output/collection for the calling client.
// TODO(morrowc): Why are the struct elements here Exported? unexport please.
type RisLive struct {
        URL     *string
        File    *string
        UA      *string
        Filter  *RisFilter
        Records int64
        Chan    chan RisMessage
}

// RisFilter is an object to hold content used to filter the collected BGP
// routes before display to the caller.
type RisFilter struct {
        ASPath           []int32        // Asath: [701, 7018, 3356] a fragment of the aspath seen.
        InvalidTransitAS map[int32]bool // {"701":true, "3356":true}.
        Origins          []string       // A list of interesting origin ASH.
        Prefix           []string       // Prefix: ["1.2.3.0/24", "2001:db8::/32"] a list of prefixes.
}

// RisMessage is a single ris_message json message from the ris firehose.
type RisMessage struct {
        Type string          `json:"type"`
        Data *RisMessageData `json:"data"`
}

// RisMessageData is the BGP oriented content of the single RisMessage message type.
type RisMessageData struct {
        Timestamp     float64       `json:"timestamp"`
        Peer          string        `json:"peer"`
        PeerASN       string        `json:"peer_asn,omitempt<span class="cov8" title="1">y"`
        ID            string        `json:"id"`
        Host          string        `json:"host"`
        Type          string  </span><span class="cov8" title="1">      `json:"type"`
        Path          []interface{} `json:"path"`
        D</span>igestedPath  []int32
        Community     [][]int32          `json:"community"`
        <span class="cov8" title="1">Origin        string             `json</span><span class="cov8" title="1">:"origin"`
        Announcements []*RisAnnouncement `json:"announcements"`
        Raw           string           </span><span class="cov8" title="1">  `json:"raw"`
}

</span>// MatchASPath matches a fragment of an aspath with an as-path in an announcement.
f<span class="cov8" title="1">unc (r *RisM</span>essageData) MatchASPath(c []int32) bool {
        cLen := len(c)
        // If the announcement's aspath is shorter than the candidate, no match is possible.
        if len(r.DigestedPath) &lt; cLen {
                return false
        }
        // Slide the candidate along the announcement path checking for <span class="cov8" title="1">a match.
        for i := 0; i+cLen &lt; len(</span><span class="cov8" title="1">r.DigestedPath); i++ {
                frag := </span><span class="cov8" title="1">r.DigestedPath[i:(i + cLen)]
                if reflect.DeepEqual(frag, c) {
                        </span>return true
                }
        <span class="cov8" title="1">}
</span>        return false
}

// InvalidTransitAS matches a se</span><span class="cov0" title="0">t of ASN in the RisMessageData.Path, returning true if
// there is a match in t</span><span class="cov0" title="0">he Path. This should be used to alert on invalid paths seen, paths
// which do not match intent/expectations of the announcing ASN.
fun</span>c (r *RisMessageData) InvalidTransitAS(c map[int32]bool) bool {
        for _, p := range r.DigestedPath {
        <span class="cov0" title="0">        if c[p] {
</span>                        return true
                }
        }
        return false
}

// CheckOrigins checks the message's bgp Origin Attribute matches a list of possible origins.
func (r *RisMessageData) CheckOrigins(origins []string) bool {
        for _, origin := range origins {
                if r.Origin == origin {
                        return true
                }
</span>        }
</span>        return false</span><span class="cov8" title="1">
}

</span>// RisAnnouncement is a struct which holds the prefixes contained in the single Bgp Message.
type RisAnnouncement struct {
        <span class="cov8" title="1">NextHop  str</span>ing   `json:"next_hop"`
        Prefixes []string `json:"prefixes"`
}

// MatchPrefix matches a list of prefixes against an announcement's included prefixes.
// Is an exact match, does not implement any super/subnet matching conditions.
func (r *RisAnnouncement) MatchPrefix(cs []string) bool {
        for _, c := range cs {
                for _, p := range r.Prefixes {
                        if c == p {
                                return true
        </span>                }
                }
        }
        return false
}

// NewRisFilter creates a new RisFilter struct.
func NewRisFilter(aspath []int32, transits map[int32]bool, origins, prefix []string) *RisFilter {
        return &amp;RisFilter{
                ASPath:           aspath,
                InvalidTransitAS: transits,
                Origins:          origins,
        </span>        Prefix:           prefix,
        }
}

// NewRisLive creates a new<span class="cov0" title="0"> RisLive struct.
func NewRisLive(url, file, ua *string, rf *RisFilter, buffer *int) *RisLive {
        return &amp;RisLive{
                URL:     url,
</span>                File:    <span class="cov0" title="0">file,
                UA:      ua,
                Filter:  rf,
                Records: 0,
                Chan:    make(</span><span class="cov0" title="0">chan (RisMessage), *buffer),
        }
}
</span>
func digestPath(m *RisMessageData) error {
        m.DigestedPath = []int32{}
        for _, p := range</span> m.Path {
                switch <span class="cov0" title="0">v := p.(type) {
                case int:
                        m.DigestedPat</span><span class="cov0" title="0">h = append(m.DigestedPath, int32(v))
                case float64:
                        </span>m.DigestedPath = append(m.DigestedPath, int32(v))
                <span class="cov0" title="0">case []interface{}:
</span>                        // Convert p to a slice of interface.
                        listSlice, ok := p.([]interface{})
        <span class="cov0" title="0">                if !ok {
                                return fmt.Errorf("failed to cast path element: %v as %v", p, reflect.TypeOf(p))
                        }
                        for _, e := r</span><span class="cov0" title="0">ange listSlice {
                                m.DigestedPath = append(m.DigestedPath, int32(e.(float64)))
                        }
</span>                default:
                        return fmt.Errorf("failed to decode path element: %v as %v", p, reflect.TypeOf(p))
                }
</span>        }
        r<span class="cov0" title="0">eturn nil
}
</span>
// Listen connects to the RisLive service, parses the stream into structs
// and makes the data stream available for analysis through the RisLive.Chan channel.
func (r *RisLive) Listen() {
        var body io.ReadCloser
        // If there's a file provided read/use that, else o<span class="cov0" title="0">pen the remote
        // s</span><span class="cov0" title="0">ocket and consume the firehose.
        switch len(*r.File) == 0 {
        case true:
                log.Infof("Reading from the firehose...")
                client := &amp;http.Client{}
</span>                req, err := http.NewRequest("GET", *r.URL, </span><span class="cov0" title="0">nil)
                if err != nil {
                        l</span>og.Fatalf("failed to create new request to ris-live: %v\n", err)
                }
                req.Header.Set("User-Agent", *r.UA)
                <span class="cov0" title="0">resp, err := client.Do(req)
                defer resp.Body.Close()
</span>                body = resp.Body
        de</span><span class="cov0" title="0">fault:
                log.Infof("Heres a file read")
                f</span>d, err := ioutil.ReadFile(*r.File)
                if err != nil {
                        log.Fatalf("failed to read risFile(%v): %v\n", *r.File, err)
                }
                body = ioutil.NopCloser(bytes.NewReader(fd))
                log.Infof("Finished Reading File")
        }

</span>        dec := json.NewDecoder(body)

</span>        <span class="cov8" title="1">// Remove l</span>og file once done.
        f, err := os.Create("/tmp/log")
        if err != nil {
                log.Fatalf("failed to open log file: %v", err)
        }
        defer f.Close()
        for {
</span>                var rm RisMessage
                </span>err := dec.Decode(&amp;rm)
        <span class="cov0" title="0">        switch {
</span>                case err != nil &amp;&amp; err != io.EOF:
                        _, err := f.WriteString(fmt.Sprintf("bad json content: %+v\n", rm.Data))
                        if err != nil {
                                log.Fatalf("failed to write to log: %v", err)
                        }
                        continue
</span>                case err == io.EOF:
                </span>        close(r.Chan)
        <span class="cov0" title="0">                return
</span>                }
                err = digestPath(rm.Data)
                if err != nil {
                        fmt.Printf("decoding the message data path(%v) failed: %v\n", rm.Data.Path, err)
                        log.Infof("decoding the message data path(%v) failed: %v", rm.Data.Path, err)
                }
                r.Records++
                r.Chan &lt;- rm
        }
}

// Get collects messages from</span><span class="cov0" title="0"> the RisLive.Chan channel and filters results prior
// to display or handling downstream.
</span>// TODO(morrowc): Why is Get accepting a</span><span class="cov0" title="0"> Filter? Why not just use the Filter in RisLive?
func (r *RisLive) Get(f *RisFilter) string</span><span class="cov0" title="0"> {
        for rm := range r.Chan </span><span class="cov0" title="0">{
                rmd := rm.Data
                pref</span>ix := ""
                // Pull a single prefix from the announcement, which may have more than one.
                if len(rmd.Announcements) &gt; 0 {
                        if len(rmd.Announcements[0].Prefixes) &gt; 0 {
                                prefix = rmd.Announcements[0].Prefixes[0]
        <span class="cov0" title="0">                        fmt.Prin</span>tf("Prefix: %v\n", prefix)
                        }
                }
                log.Infof("Got a prefix: %v / announcement\n", prefix)
                // TODO(morrowc): This doesn't appear to be working properly.
                // the logic here needs to be more complicated, depending upon what's set
                // in the filter to check. Suggest make 'checkTests' like function, evaluate
                // so only the set filter parts matter.
                if r.CheckASPath(rmd) &amp;&amp; r.CheckInvalidTransitAS(rmd) &amp;&amp;
                        r.CheckOrigins(rmd) &amp;&amp; r.CheckPrefix(rmd) {
                        return fm<span class="cov0" title="0">t.Sprintf("Message(%d): Peer/ASN -&gt; %v/%v Prefix1: %v\n", r.Records, rmd.Peer, rmd.PeerASN, prefix)
                }
        }
        return "Done"
}

/</span>/ CheckASPath checks the filterable ASPath, if it's set.
// If not set, always return true.
func (r *RisLive) CheckASPath(rm *RisMessageData) bool {
        if len(r.Filter.ASPath) &gt; 0 {
                return rm.MatchASPath(r.Filter.ASPath)
        }
        return true
}

// CheckInvalidTransitAS checks to see if there is a marked invalid ASN in the as-path.
// If there is no map, this check returns false: there is nothing to match, so no match.
func (r *RisLive) CheckInvalidTransitAS(rm *RisMessageData) bool {
        if len(r.Filter.InvalidTransitAS) &gt; 0 {
                return rm.InvalidTransitAS(r.Filter.InvalidTransitAS)
        }
        return false
}

// CheckOrigins checks the inbound message origin against a list of possible origins.
// If there is no list of origins, return false, an origin must be specified in the filter.
func (r *RisLive) CheckOrigins(rm *RisMessageData) bool {
        if len(r.Filter.Origins) &gt; 0 {
                return rm.CheckOrigins(r.Filter.Origins)
        }
        return false
}

// CheckPrefix will check each announcement in a message, and return true
// if there is a prefix in the message that matches the watched prefixes.
// These are exact matches of strings, there is no super/subnet/covering route
// check being performed, ie:
//   192.168.0.0/16 vs 192.168.0.0/16 - match
//   192.168.0.0/16 vs 192.168.0.0/24 - no match
// TODO(morrowc): Provide super/subnet verification of each announced prefix
// to the requestors list of supernets.
func (r *RisLive) CheckPrefix(rm *RisMessageData) bool {
        if len(r.Filter.Prefix) &gt; 0 {
                filterPrefixes := []*net.IPNet{}
                for _, prefix := range r.Filter.Prefix {
                        _, subnet, err := net.ParseCIDR(prefix)
                        if err != nil {
                                log.Infof("failed to convert filter prefix(%v) to IPNet: %v", prefix, err)
                                continue
                        }
                        filterPrefixes = append(filterPrefixes, subnet)
                }
                for _, anns := range rm.Announcements {
                        for _, prefix := range anns.Prefixes {
                                for _, check := range filterPrefixes {
                                        announcementIP, _, err := net.ParseCIDR(prefix)
                                        if err != nil {
                                                log.Infof("announcement prefix(%v) not parsed as CIDR: %v", prefix, err)
                                                continue
                                        }
                                        if check.Contains(announcementIP) {
                                                return true
                                        }
                                }
                        }
                }
        }
        return false
}

func main() {
        flag.Parse()
        rf := &amp;RisFilter{
                Prefix:  []string{"130.137.85.0/24", "199.168.88.0/22", "8.8.8.0/24", "8.8.4.0/24", "216.239.32.0/19"},
                Origins: []string{"15169", "54054", "396982"},
        }
        r := NewRisLive(risLive, risFile, risClient, rf, buffer)

        go r.Listen()
        result := r.Get(r.Filter)
        fmt.Printf("Result: %v\n", result)
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
