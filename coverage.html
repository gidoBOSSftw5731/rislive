
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">./rislive.go (28.2%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">// Package rislive implements a service to listen to the RIPE RIS Live service,
// Messages from RIS Live are parsed and sent to a channel for use be clients.
// There are filter capabilities for clients:
//  ASPaths - monitor for prefixes matching an as-path fragment (slice)
//  InvalidTransitAS - monitor for prefixes transiting an AS that shouldn't transit that AS. (map)
//  Origins - monitor for prefixes with designated origins (slice)
//  Prefix - monitor for a designated set of prefixes (slice)
//
package main

import (
        "bytes"
        "encoding/json"
        "flag"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "reflect"
)

// RisLive is a struct to hold basic data used in connecting to the RIS Live service
// and managing data output/collection for the calling client.
type RisLive struct {
        Url     *string
        File    *string
        UA      *string
        Filter  *RisFilter
        Records int64
        Chan    chan RisMessage
}

// RisFilter is an object to hold content used to filter the collected BGP
// routes before display to the caller.
type RisFilter struct {
        ASPath           []int32        // Asath: [701, 7018, 3356] a fragment of the aspath seen.
        InvalidTransitAS map[int32]bool // {"701":true, "3356":true}.
        Origins          []string       // A list of interesting origin ASH.
        Prefix           []string       // Prefix: ["1.2.3.0/24", "2001:db8::/32"] a list of prefixes.
}

// RisMessage is a single ris_message json message from the ris firehose.
type RisMessage struct {
        Type string          `json:"type"`
        Data *RisMessageData `json:"data"`
}

// RisMessageData is the BGP oriented content of the single RisMessage message type.
type RisMessageData struct {
        Timestamp     float64            `json:"timestamp"`
        Peer          string             `json:"peer"`
        PeerASN       string             `json:"peer_asn,omitempty"`
        Id            string             `json:"id"`
        Host          string             `json:"host"`
        Type          string             `json:"type"`
        Path          []int32            `json:"path"`
        Community     [][]int32          `json:"community"`
        Origin        string             `json:"origin"`
        Announcements []*RisAnnouncement `json:"announcements"`
        Raw           string             `json:"raw"`
}

// MatchASPath matches a fragment of an aspath with an as-path in an announcement.
func (r *RisMessageData) MatchASPath(c []int32) bool {
        cLen := len(c)
</span>        // If the announcement's aspath is shorter than the candidate, no match is possible.
        i</span>f len(r.Path) &lt; cLen {
                return false
        <span class="cov8" title="1">}
</span>        // Slide the candidate along the announcement path checking for a match.
        for i := 0; i+cLen &lt; len(r.Path</span><span class="cov8" title="1">); i++ {
                frag := r.Path[i:(i + cLen)]
                i</span>f reflect.DeepEqual(frag, c) {
                        return true
        <span class="cov8" title="1">        }
</span>        }
        return false
}

// InvalidTransitAS matches a set of ASN in the RisMessageData.Path, returning true if
// there is a match in the Path. This should be used to alert on <span class="cov8" title="1">invalid paths seen, paths
// which do not match inte</span><span class="cov8" title="1">nt/expectations of the announcing ASN.
func (r *R</span><span class="cov8" title="1">isMessageData) InvalidTransitAS(c map[int32]bool) bool {
        for _, p := range r.Path {
                i</span>f c[p] {
                        return true
        <span class="cov8" title="1">        }
</span>        }
        return false
}

</span>func (r *RisMessageData)</span><span class="cov0" title="0"> CheckOrigins(origins []string) bool {
        for _, origin := range origins {
                i</span>f r.Origin == origin {
                        return true
        <span class="cov0" title="0">        }
</span>        }
        return false
}

// RisAnnouncement is a struct which holds the prefixes contained in the single Bgp Message.
type RisAnnouncement struct {
        NextHop  string   `json:"next_hop"`
        Prefixes []string `json:"prefixes"`
}

// MatchPrefix matches a list of prefixes against an ann<span class="cov8" title="1">ouncement's included prefixes.
// Is an exact match, </span><span class="cov8" title="1">does not implement any super/subnet matching conditions.
func (r *RisAnnouncement) Match</span><span class="cov8" title="1">Prefix(cs []string) bool {
        for _, c := </span><span class="cov8" title="1">range cs {
                for _, p := range r.Prefixes {
                        i</span>f c == p {
                                return true
                        }
        <span class="cov8" title="1">        }
</span>        }
        return false
}

// NewRisFilter creates a new RisFilter struct.
func NewRisFilter(aspath []int32, transits map[int32]bool, origins, prefix []string) *RisFilter {
        return &amp;RisFilter{
                ASPath:           aspath,
                InvalidTransitAS: transits,
                Origins:          origins,
        </span>        Prefix:           prefix,
        }
}

// NewRisLive creates a new RisLive struct.
func NewRisLive(url, file, ua *string, rf *RisFilter, buffer *int) *RisLive {
        return &amp;RisLive{
                Url:     url,
                File:    file,
                UA:      ua,
                Filter:  rf,
                Records: 0,
        </span>        Chan:    make(chan (RisMessage), *buffer),
        }
}

// Listen connects to the R<span class="cov0" title="0">isLive service, parses the stream into structs
// and makes the data stream available for analysis through the RisLive.Chan channel.
func (r *RisLive) Listen()</span> {
        var body i<span class="cov0" title="0">o.ReadCloser
        // TODO(morrowc) This appears to not work as expected.
        switch len(*r.File) == 0 {
        case true:
</span>                fmt.Println("Heres a file read")
                c</span>lient := &amp;http.Client{}
                <span class="cov0" title="0">req, err := http.NewRequest("GET", *r.Url, nil)
                if err != nil {
                        fmt.Printf("failed to create new request to ris-live: %v\n", err)
                }
</span>                req.Hea<span class="cov0" title="0">der.Set("User-Agent", *r.UA)
                resp, err := client.Do(req)
                defer resp.Bod</span><span class="cov0" title="0">y.Close()
                body = resp.Body
        de</span>fault:
                <span class="cov0" title="0">fd, err := ioutil.ReadFile(*r.File)
</span>                if err != nil {
                        fmt.Printf("failed to read risFile(%v): %v\n", *r.File, err)
        <span class="cov0" title="0">        }
                body = ioutil.NopCloser(bytes.NewReader(fd))
        }

</span>        dec := json.NewDecoder(body)

</span>        var rm RisMessage
        for dec.More() {
                err := dec.Decode(&amp;rm)
                i</span>f err != nil {
                <span class="cov0" title="0">        fmt.Printf("failed to decode json: %v\n", err)
                        fmt.Printf(</span>"bad json content: %v\n", rm)
                        return
                }
                r.Records++
                r.Chan &lt;- rm
        }
}
</span>
// Get collects messages from the RisLive.Chan channel and filters results prior
// to display or handling downstream.
func (r *RisLive) Get(f *RisFilt</span><span class="cov0" title="0">er) chan RisMessage {
        for {
</span>                rm := &lt;-r.Chan
                rm</span>d := rm.Data
                prefix := ""
                <span class="cov0" title="0">if len(rmd.Announcements) &gt; 0 {
</span>                        if len(rmd.Announcements[0].Prefixes) &gt; 0 {
                                prefix = rmd.Announcements[0].Prefixes[0]
                        }
                }
                if r.CheckASPath(rmd) || r.CheckInvalidTransitAS(rmd) ||
                        r.CheckOrigins(rmd) || r.CheckPrefix(rmd) {
                        fmt.Printf("Message(%d): P</span><span class="cov8" title="1">eer/ASN -&gt; %v/%v Prefix1: %v\n", r.Records, rmd.Peer, rmd.PeerASN, prefix)
                } else {
                </span>        fmt.Printf("Skipped message for %s \n", prefix)
        <span class="cov8" title="1">        }
</span>        }
}

// CheckASPath checks the filterable ASPath, if it's set.
// If not set, always return true.
func (r *RisLive) CheckASPath(rm *RisMe</span><span class="cov0" title="0">ssageData) bool {
        if len(r.Filter.ASPath) &gt; 0 {
                </span>return rm.MatchASPath(r.Filter.ASPath)
        <span class="cov0" title="0">}
</span>        return true
}

// CheckInvalidTransitAS checks to see if there is a marked invalid ASN in the as-path.
// If there is no map, this check returns false: there i<span class="cov0" title="0">s nothing to match, so no match.
func (r *RisLive) CheckInvalid</span><span class="cov0" title="0">TransitAS(rm *RisMessageData) bool {
        if len(r.Filter.InvalidTransitAS) &gt; 0 {
                </span>return rm.InvalidTransitAS(r.Filter.InvalidTransitAS)
        <span class="cov0" title="0">}
</span>        return false
}

// CheckOrigins checks the inbound message origin against a list of possible origins.
// If there is no list of origins, return true: no match means show all origins.
func (r *RisLive) CheckOrigins(rm *RisMessageData) bool {
        if len(r.Filter.Origins) &gt; 0 {
                return rm.CheckOrigins(r.Filter.Origins)
        }
        return true
}

</span>// CheckPrefix will check each announcem</span><span class="cov0" title="0">ent in a message, and return true
// if there is a prefix in the message t</span><span class="cov0" title="0">hat matches the watched prefixes.
// These are exact matches of strings, the</span><span class="cov0" title="0">re is no super/subnet/covering route
// check being performed</span><span class="cov0" title="0">, ie:
//   192.168.0.0/16 vs 192.168.0.0/16 - match
//   1</span>92.168.0.0/16 vs 192.168.0.0/24 - no match
// TODO(morrowc): Provide super/subnet verification of each announced prefix
// to the requestors list of supernets.
func (r *RisLive) CheckPrefix(rm *RisMessageData) bool {
        if len(r.Filter.Prefix) &gt; 0 {
        <span class="cov0" title="0">        for _, ann</span>s := range rm.Announcements {
                        for _, prefix := range anns.Prefixes {
                                for _, check := range r.Filter.Prefix {
                                        if prefix == check {
                                                return true
                                        }
                                }
                        }
                }
        }
        return true
}

var (
        risFile   = flag.String("risFile", "", "A file of json content, to help in testing.")
        risLive   = flag.String("rislive", "https://ris-live.ripe.net/v1/stream/?format=json", "RIS Live firehose url")
        risClient = flag.String("risclient", "golang-rislive-morrowc", "Clientname to send to rislive")
        buffer    = flag.Int("buffer", 1000, "Max depth of Ris messages to queue.")
)

func main() {
        rf := &amp;RisFilter{Prefix: []string{"130.137.85.0/24", "199.168.88.0/22", "8.8.8.0/24", "8.8.4.0/24", "216.239.32.0/19"}}
        r := NewRisLive(risLive, risFile, risClient, rf, buffer)

        go r.Listen()
        _ = r.Get(r.Filter)
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
